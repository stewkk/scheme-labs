* Лекция 12. Вычисления на стеке, конкатенативное программирование
  :PROPERTIES:
  :CUSTOM_ID: лекция-12.-вычисления-на-стеке-конкатенативное-программирование
  :END:
*Конкатенативное программирование* --- парадигма программирования,
в которой композиция функций выражается через конкатенацию строк.
Примеры языков: FORTH, Joy, Factor.

Т.е. пусть у нас есть две программы =P1= и =P2=, конкатенация этих двух
программ =P1 P2= будет выражать применение =P2= к результату выполнения
=P1=.

В конкатенативных языках явных переменных нет, данные передаются неявно,
через стек. Программа представляет собой последовательность операторов,
каждый из которых выполняет какую либо операцию со стеком. Частный
случай: константы --- это тоже операторы, которые на стек кладут
соответствующее значение.

В конкатенативных языках программирования принято записывать стек,
растущий слева направо, причём верхушка стека расположена справа.

Действия операторов принято записывать как

#+begin_example
  оператор : ... стек до  =>  ... стек после
#+end_example

Например:

#+begin_example
  + : ... x y  =>  ... (x+y)
#+end_example

Программа пишется в обратной польской записи или постфиксной записи:
сначала записываются операнды, а потом сама операция.

*Местность (арность) операции, функции* --- количество операндов
(аргументов) у неё.

*Коместность (коарность)* --- количество возвращаемых значений.

Поскольку местность каждой операции фиксирована, скобки не нужны.

Пример.

Выражение в обычной (инфиксной записи):

#+begin_example
  (2 - 1) * (3 + 4)
#+end_example

Выражение в постфиксной записи (обратной польской):

#+begin_example
  2 1 - 3 4 + *
#+end_example

- Аргументы операции =-=: =2= и =1=,
- аргументы операции =+=: =3= и =4=,
- аргументы =*=: =2 1 -=, =3 4 +=.

Можно добавить скобки для наглядности, но их никто не ставит:

#+begin_example
  ((2 1 -) (3 4 +) *)
#+end_example

Местность констант 0 (не принимают аргументов), коместность --- 1.

#+begin_example
  константа : ...  =>  ... константа
#+end_example

Обратная польская запись допускает простую и эффективную реализацию:

- в цикле читаем очередную операцию,
- снимаем со стека соответствующее количество аргументов операции,
- выполняем операцию,
- кладём на стек её результаты.

Пример:

#+begin_example
  Стек                Программа

  ...                 2 1 - 3 4 + *
                      ↑
  ... 2               2 1 - 3 4 + *
                        ↑
  ... 2 1             2 1 - 3 4 + *
                          ↑
  ... 1               2 1 - 3 4 + *
                            ↑
  ... 1 3             2 1 - 3 4 + *
                              ↑
  ... 1 3 4           2 1 - 3 4 + *
                                ↑
  ... 1 7             2 1 - 3 4 + *
                                  ↑
  ... 7               2 1 - 3 4 + *
                                    ↑
  программа завершилась
#+end_example

** Как выполняются вызовы функций в стековом языке программирования
   :PROPERTIES:
   :CUSTOM_ID: как-выполняются-вызовы-функций-в-стековом-языке-программирования
   :END:
Функции в FORTH принято называть *статьями,* хранилище функций ---
*словарём.*

Программа на языке FORTH состоит из последовательности *слов,* словом
может быть или целочисленная константа, или некоторое имя. Часть слов
предопределены (встроены в язык), часть определяются пользователем
в виде статей:

Определение статьи выглядит так

#+begin_example
   : ИМЯ  слова…  ;
#+end_example

Знак =:= начинает определение, знак =;= --- заканчивает.

Для вызовов функций вводится второй стек --- *стек возвратов.*
В основном стеке, *стеке данных* находятся значения, которыми
обмениваются операции, в классическом FORTH'е это целые числа. В стеке
возвратов хранятся адреса команд в словарных статьях.

Интерпретатор работает в следующем цикле:

- Если в статье слова не кончились, читается очередное слово.

  - Если слово есть в словаре, адрес следующего слова кладётся на стек
    возвратов, управление передаётся на первое слово словарной статьи.
  - Если нет в словаре и слово является записью целого числа, то число
    кладётся на стек данных.
  - Если слова нет в словаре и оно не является записью числа --- ОШИБКА.

- Если слова в статье кончились --- со стека возвратов снимается адрес
  следующего слова и передаётся на него управление.

Некоторые встроенные слова FORTH:

- Арифметика: =+=, =-=, =*=, =/=.

- Слова работы со стеком:

  #+begin_example
    DUP :  ... x      =>  ... x x    -- дублирует верхушку стека
    DROP : ... x      =>  ...        -- удаляет слово с верхушки стека
    SWAP : ... x y    =>  ... y x    -- обменивает местами два слова на верхушке
    ROT :  ... x y z  =>  ... y z x  -- поднимает на верхушку третий по счёту элемент
    OVER : ... x y    =>  ... x y x  -- копирует подвершину на верхушку
  #+end_example

- Управляющие конструкции

  - =IF ... THEN= --- если на вершине не ноль, выполняются слова между
    =IF= и =THEN=, иначе ничего не делается. В обоих случаях число
    со стека снимается.
  - =IF ... ELSE ... THEN= --- если на верхушке не ноль, он снимается
    с верхушки и выполняются слова между =IF= и =ELSE=, иначе ноль
    снимается с верхушки и выполняются слова между =ELSE= и =THEN=.
  - =WHILE ... WEND= --- цикл с предусловием повторяется до тех пор,
    пока на верхушке не ноль.

- Ввод-вывод

  #+begin_example
    . : ... x  =>  ...               -- печатает число, снимая его со стека
  #+end_example

Пример программы на FORTH. Функция (слово) =hypot= вычисляет гипотенузу
прямоугольного треугольника:

#+begin_example
  \ square : ... x  =>  ... x²
  : square DUP * ;

  \ hypot : ... x y  =>  ... √(x²+y²)
  : hypot square SWAP square + SQRT ;
#+end_example

Выполнение слова =square=:

#+begin_example
  Стек             Программа
  --------------------------
  ... x            DUP * ;
                   ↑
  ... x x          DUP * ;
                       ↑
  ... x²           DUP * ;
                         ↑
  происходит возврат из square
#+end_example

Выполнение слова =hypot=:

#+begin_example
  Стек             Программа
  --------------------------
  ... x y          square SWAP square + SQRT ;
                   ↑
#+end_example

Когда слово =square= вызывается, на стек возвратов кладётся указатель
на слово =SWAP= в определении слова =hypot=.

#+begin_example
  Стек             Программа
  --------------------------
  ... x y²         square SWAP square + SQRT ;
                          ↑
  ... y² x         square SWAP square + SQRT ;
                               ↑
  ... y² x²        square SWAP square + SQRT ;
                                      ↑
  ... y²+x²        square SWAP square + SQRT ;
                                        ↑
  ... √(y²+x²)     square SWAP square + SQRT ;
                                             ↑
  происходит возврат из hypot
#+end_example

Пример, характерный для FORTH:

#+begin_example
  : 2 3 ;
  2 2 * .
#+end_example

Она выведет =9=, а не =4=.

#+begin_example
  : + - ;
  10 5 + .
#+end_example

Выведет =5=, а не =15=.

Слово с переменным числом параметров:

#+begin_example
  : SUM DUP WHILE + SWAP DUP WEND DROP ;
#+end_example

Сложит все числа на стеке до ближайшего нуля.

#+begin_example
  1 2 3 0 4 5 6 SUM   =>  1 2 3 15
  ===== ~~~~~~~           ===== ~~

  1 2 3 0 4 5 6          DUP WHILE + SWAP DUP WEND DROP ;
                         ↑
  1 2 3 0 4 5 6 6        DUP WHILE + SWAP DUP WEND DROP ;
                             ↑
  1 2 3 0 4 5 6          DUP WHILE + SWAP DUP WEND DROP ;
                                   ↑
  1 2 3 0 4 11           DUP WHILE + SWAP DUP WEND DROP ;
                                     ↑
  1 2 3 0 11 4           DUP WHILE + SWAP DUP WEND DROP ;
                                          ↑
  1 2 3 0 11 4 4         DUP WHILE + SWAP DUP WEND DROP ;
                                              ↑
  1 2 3 0 11 4 4         DUP WHILE + SWAP DUP WEND DROP ;
                             ↑
  1 2 3 0 11 4           DUP WHILE + SWAP DUP WEND DROP ;
                                   ↑
  1 2 3 0 15             DUP WHILE + SWAP DUP WEND DROP ;
                                     ↑
  1 2 3 15 0             DUP WHILE + SWAP DUP WEND DROP ;
                                          ↑
  1 2 3 15 0 0           DUP WHILE + SWAP DUP WEND DROP ;
                                              ↑
  1 2 3 15 0 0           DUP WHILE + SWAP DUP WEND DROP ;
                             ↑
  1 2 3 15 0             DUP WHILE + SWAP DUP WEND DROP ;
                                                   ↑
  1 2 3 15               DUP WHILE + SWAP DUP WEND DROP ;
                                                        ↑
#+end_example
