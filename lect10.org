* Лекция 10. Стек вызовов в Scheme. Продолжения
  :PROPERTIES:
  :CUSTOM_ID: лекция-10.-стек-вызовов-в-scheme.-продолжения
  :END:
В сегодняшней лекции мы рассмотрим, как интерпретатор Scheme выполняет
вызовы функций и какие средства контроля за этим Scheme даёт
программисту.

** Стек вызовов. Как осуществляются вызовы функций на Scheme
   :PROPERTIES:
   :CUSTOM_ID: стек-вызовов.-как-осуществляются-вызовы-функций-на-scheme
   :END:
Выполнение программы на языке Scheme состоит из двух этапов: раскрытие
всех макроподстановок и синтаксического сахара до базовых примитивов
языка и выполнение программы, записанной в терминах этих базовых
примитивов. Сегодня мы будем рассматривать второй этап вычислений,
поэтому большинство примеров кода будет написано в терминах базовых
примитивов.

В число базовых примитивов, помимо =define=, =if=, =lambda=, =quote=,
=set!=, мы добавим также =begin= для удобства изложения (хотя он может
быть выражен через =let=, а тот, в свою очередь, через =lambda=).

Процесс вычисления выражений мы будем изображать путём редукции:
выбираем очередное подвыражение и заменяем его на результат.

*Пример.* Рассмотрим редукцию выражения

#+begin_example
  ((lambda (foo bar)
     (begin
       (set! bar (+ foo bar))
       (* foo bar 2)))
   3 4)
#+end_example

Шаги редукции:

#+begin_example
  Выражение                                              Среда

  ((lambda (foo bar) (begin (set! bar (+ foo bar)) (* foo bar 2))) 3 4)
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  ; вызывается lambda, появляется среда с локальными переменными

  (begin (set! bar (+ foo bar)) (* foo bar 2))           foo → 3, bar → 4
                      ^^^
  ; подстановка значения вместо переменной foo

  (begin (set! bar (+ 3 bar)) (* foo bar 2))             foo → 3, bar → 4
                        ^^^
  ; подстановка значения вместо переменной bar

  (begin (set! bar (+ 3 4)) (* foo bar 2))               foo → 3, bar → 4
                    ^
  ; вызов встроенной функции +

  (begin (set! bar 7) (* foo bar 2))                     foo → 3, bar → 4
          ^^^^
  ; выполнение оператора присваивания

  (begin #<void> (* foo bar 2))                          foo → 3, bar → 7
   ^^^^^
  ; редукция begin

  (* foo bar 2)                                          foo → 3, bar → 7
     ^^^
  ; подстановка значения вместо переменной foo

  (* 3 bar 2)                                            foo → 3, bar → 7
       ^^^
  ; подстановка значения вместо переменной bar

  (* 3 7 2)                                              foo → 3, bar → 7
   ^
  ; вызов встроенной функции *

  42
#+end_example

При выполнении вызовов функций мы будем предполагать, что аргументы
вычисляются слева направо. Согласно [[file:r5rs.pdf][R5RS]], порядок
вычислений не определён, но среда DrRacket вычисляет их слева направо.
Также, вслед за DrRacket, будем считать, что операция =set!= и функции
типа =display= возвращают значение типа =#<void>= (согласно R5RS
значение также не определено).

В последующих выкладках некоторые очевидные шаги редукции (вроде
подстановки значений вместо переменных) мы будем опускать.

В примере на редукцию выше, мы не касались вопроса о механизме вызовов
функций. Сейчас рассмотрим его подробнее.

По курсу «Алгоритмы и структуры данных» мы знакомы с понятием «стек
вызовов» и с тем, как в языке Си осуществляются вызовы функций:

#+caption: Фреймы функций в автоматической памяти
[[file:pics/module_clang-15.png]]

#+caption: Поддержка рекурсии
[[file:pics/module_clang-16.png]]

В языке Scheme дело обстоит аналогичным образом, с той лишь разницей,
что и фреймы стека, и данные распределяются в динамической памяти.
И если ссылка на фрейм где-то сохранена, то объект фрейма останется
«жить» даже после возврата функции.

Фреймы стека языка Си содержат адрес возврата и локальные переменные.
Параметры функций являются разновидностью локальных переменных.

Как мы помним, конструкции =let=, =let*= и =letrec=, а также =define=
внутри =begin=, вводящие локальные переменные, являются синтаксическим
сахаром, реализованным поверх =lambda=. Поэтому для языка Scheme
локальные переменные во фреймах стека --- это /только/ параметры
функций.

Фрейм стека будем изображать следующим образом:

#+caption: 0000-frame.dot
[[file:pics/gen/0000-frame.png]]

Фрейм стека содержит две ссылки. Одна из называется «среда» и ссылается
на значения локальных переменных --- аргументов функции. Вторая ---
«возврат» ссылается на предыдщий фрейм стека. Если фрейм стека
не верхний, то выражение будет содержать символ =●=, означающий точку,
куда будет возвращено выполнение вызова другой функции.

Рассмотрим пример --- вычисление числа Фибоначчи по номеру. Пусть нам
дана функция

#+begin_example
  (define fib
    (lambda (n)
      (if (= n 0)
          1
          (if (= n 1)
              1
              (+ (fib (- n 1)) (fib (- n 2)))))))
#+end_example

Рассмотрим процесс вычисления выражения

#+begin_example
  (display (fib 3))
#+end_example

Начальное состояние:

#+caption: 1010-fib.dot
[[file:pics/gen/1010-fib.png]]

Создаётся фрейм стека для =(fib 3)=:

#+caption: 1010-fib.png
[[file:pics/gen/1010-fib.png]]

Подстановка значения вместо переменной в =if=:

#+caption: 1020-fib.png
[[file:pics/gen/1020-fib.png]]

Аргументы для встроенной функции === вычислены, вызов встроенной
функции. Имена переменных в среде не указаны, т.к. функция встроенная
и мы их не знаем.

#+caption: 1030-fib.png
[[file:pics/gen/1030-fib.png]]

Функция === вернула ложь:

#+caption: 1040-fib.png
[[file:pics/gen/1040-fib.png]]

Редукция =if=:

#+caption: 1050-fib.png
[[file:pics/gen/1050-fib.png]]

Подстановка значения переменной:

#+caption: 1060-fib.png
[[file:pics/gen/1060-fib.png]]

Вызов ===:

#+caption: 1070-fib.png
[[file:pics/gen/1070-fib.png]]

Фрейм стека для ===:

#+caption: 1080-fib.png
[[file:pics/gen/1080-fib.png]]

Возврат =#f= из === (опущен), редукция =if=:

#+caption: 1090-fib.png
[[file:pics/gen/1090-fib.png]]

Подстановка значения переменной:

#+caption: 1095-fib.png
[[file:pics/gen/1095-fib.png]]

Аргументы у встроенной функции =-= вычислены, её вызов и фрейм стека:

#+caption: 1100-fib.png
[[file:pics/gen/1100-fib.png]]

Возврат из функции =-=:

#+caption: 1110-fib.png
[[file:pics/gen/1110-fib.png]]

Рекурсивный вызов =fib=:

#+caption: 1120-fib.png
[[file:pics/gen/1120-fib.png]]

Очевидные вызовы === и шаги редукции =if= пропускаем:

#+caption: 1130-fib.png
[[file:pics/gen/1130-fib.png]]

Вычисление =(- n 1)= → =(- 2 1)= → =1=:

#+caption: 1140-fib.png
[[file:pics/gen/1140-fib.png]]

Рекурсивный вызов =fib=:

#+caption: 1150-fib.png
[[file:pics/gen/1150-fib.png]]

Вычисление =(= n 0)= → =(= 1 0)= → =#f=:

#+caption: 1160-fib.png
[[file:pics/gen/1160-fib.png]]

Редукция =if=:

#+caption: 1170-fib.png
[[file:pics/gen/1170-fib.png]]

Вычисление =(= n 1)= → =(= 1 1)= → =#t=:

#+caption: 1180-fib.png
[[file:pics/gen/1180-fib.png]]

Редукция =if=:

#+caption: 1190-fib.png
[[file:pics/gen/1190-fib.png]]

Возврат вычисленного значения:

#+caption: 1200-fib.png
[[file:pics/gen/1200-fib.png]]

Вычисление =(- n 2)= → =(- 2 2)= → =0=:

#+caption: 1210-fib.png
[[file:pics/gen/1210-fib.png]]

Рекурсивный вызов =fib=:

#+caption: 1220-fib.png
[[file:pics/gen/1220-fib.png]]

Вычисление =(= n 0)= → =(= 0 0)= → =#t=:

#+caption: 1230-fib.png
[[file:pics/gen/1230-fib.png]]

Редукция =#if=, возврат из функции:

#+caption: 1240-fib.png
[[file:pics/gen/1240-fib.png]]

Вычисление =(+ 1 1)= → =2=:

#+caption: 1250-fib.png
[[file:pics/gen/1250-fib.png]]

Возврат из функции:

#+caption: 1260-fib.png
[[file:pics/gen/1260-fib.png]]

** Рисунки «на доске»
   :PROPERTIES:
   :CUSTOM_ID: рисунки-на-доске
   :END:
#+caption: 1.jpg
[[file:pics/scan/1.jpg]]

#+caption: 2.jpg
[[file:pics/scan/2.jpg]]

#+caption: 3.jpg
[[file:pics/scan/3.jpg]]

#+caption: 4.jpg
[[file:pics/scan/4.jpg]]

#+caption: 5.jpg
[[file:pics/scan/5.jpg]]

#+caption: 6.jpg
[[file:pics/scan/6.jpg]]

#+caption: 7.jpg
[[file:pics/scan/7.jpg]]

#+caption: 8.jpg
[[file:pics/scan/8.jpg]]

#+caption: 9.jpg
[[file:pics/scan/9.jpg]]

#+caption: 10.jpg
[[file:pics/scan/10.jpg]]

#+caption: 11.jpg
[[file:pics/scan/11.jpg]]

#+caption: 12.jpg
[[file:pics/scan/12.jpg]]

#+caption: 13.jpg
[[file:pics/scan/13.jpg]]

#+caption: 14.jpg
[[file:pics/scan/14.jpg]]

#+caption: 15.jpg
[[file:pics/scan/15.jpg]]

#+caption: 16.jpg
[[file:pics/scan/16.jpg]]

#+caption: 17.jpg
[[file:pics/scan/17.jpg]]

#+caption: 18.jpg
[[file:pics/scan/18.jpg]]
