* Лекция 3. Функции высшего порядка
  :PROPERTIES:
  :CUSTOM_ID: лекция-3.-функции-высшего-порядка
  :END:
Значения языка Scheme:

- Числа: 1, 1.0, 6.022e23, 1/3...

- Строки: "Scheme"

- Логический тип: #t, #f

- Литерный (character) тип: #\a #\newline ...

- Символьный (symbol) тип: 'x, 'sin...

- ...

- *Процедурный тип*

  (lambda (аргументы) выражение)

Конструкция lambda создаёт безымянную процедуру. Эту процедуру можно
вызвать:

#+begin_example
  ((lambda (x y) (+ x y)) 10 13)
  ;         ^--- формальные параметры
  ;фактические параметры --^
#+end_example

При вызове процедуры создаются новые переменные, соответствующие
формальным параметрам и они связываются с фактическими параметрами.

#+begin_example
  (define f
    (lambda (x y) (+ x y)))
  (f 10 13)
#+end_example

Синтаксический сахар:

#+begin_example
  (define f (lambda (парам) выраж))
#+end_example

эквивалентно

#+begin_example
  (define (f парам) выраж)
#+end_example

Передача процедуры как параметра:

#+begin_example
  (define (g f)
    (f 10 13))

  (g (lambda (x y) (+ x y)))
  (g +)
#+end_example

Возврат процедуры из процедуры

#+begin_example
  (define (select n)
    (if (> n 0)
        (lambda (x y) (+ x y))
        (lambda (x y) (- x y))))

  ((select +1) 10 13)
  ((select -1) 100 50)
#+end_example

* Управляющие конструкции языка Scheme
  :PROPERTIES:
  :CUSTOM_ID: управляющие-конструкции-языка-scheme
  :END:
** Конструкции let, let* и letrec
   :PROPERTIES:
   :CUSTOM_ID: конструкции-let-let-и-letrec
   :END:
#+begin_example
  (let ((var1 expr1)
        (var2 expr2)
        ...
        (varN exprN))
    выражение)
#+end_example

В теле let-выражения можно использовать переменные var1...varN.
Выражения expr1...exprN могут вычисляться в произвольном порядке -
порядок их вычисления не определён.

НО! Внутри expr1...exprN нельзя использовать var1...varN.

#+begin_example
  (let ((x (+ y z)))
     (* x x))


  (let* ((var1 expr1)
         (var2 expr2)
         ...
         (varN exprN))
    body)
#+end_example

Переменную varK можно использовать не только в теле let*, но и в exprM,
где M > K.

Выражения expr1...exprN вычисляются /последовательно./

#+begin_example
   (letrec ((var1 expr1)
            (var2 expr2)
            ...
            (varN exprN))
    body)
#+end_example

Внутри любого exprK можно использовать любую переменную из var1...varN.

Все эти конструкции являются синтаксическим сахаром. Для примера:

#+begin_example
  (let ((var1 expr1)
        (var2 expr2)
        ...
        (varN exprN))
    выражение)
#+end_example

эквивалентна

#+begin_example
  ((lambda (var1 ... varN)
     выражение)
   expr1 ... exprN)
#+end_example

*** "let с рекурсией"
    :PROPERTIES:
    :CUSTOM_ID: let-с-рекурсией
    :END:
#+begin_example
  (let proc-name ((var1 expr1)
                  (var2 expr2)
                  ...
                  (varN exprN))
    body)
#+end_example

Внутри тела let-выражения можно вызывать процедуру proc-name, передавая
ей N параметров.

Это выражение эквивалентно

#+begin_example
  (letrec ((proc-name
            (lambda (var1 ... varN)
              body)))
    (proc-name expr1 ... exprN))
#+end_example

* Рекурсия, итерация и хвостовая рекурсия
  :PROPERTIES:
  :CUSTOM_ID: рекурсия-итерация-и-хвостовая-рекурсия
  :END:
N! = 1/2/3/.../(N-1)*N

0! = 1 N! = N * (N-1)!

Рекурсия - делим задачу на меньшие подзадачи, подобные исходной.

Итерация - задача делится на некоторое количество одинаковых подзадач,
одинаковых шагов, приближающих к цели.

Как итерацию выразить через рекурсию?

Итерация: пока цель не достигнута, повторять шаг вычисления.

Рекурсия: * Цель достигнута? * Да - прекратить вычисления, вернуть
результат. * Нет - выполнить один шаг вычисления, выполнить рекурсивный
вызов.

Факториал в терминах итерации:

#+begin_example
  int fact(int N) {
    int res = 1;
    int i = 1;
    while (i <= N) {
      res = res * i;
      i = i + 1;
    }
    return res;
  }
#+end_example

- Для цикла заводим вспомогательную процедуру.

- Переменные цикла становятся параметрами процедуры.

- Тело цикла превращается в рекурсивный вызов.

- Инициализация переменных цикла становится вызовом рекурсивной
  процедуры.

  (define (fact N) (define (loop i res) (if (<= i N) (loop (+ i 1) (*
  res i)) res)) (loop 1 1))

  (define (fact N) (let loop ((i 1) (res 1)) (if (<= i N) (loop (+ i 1)
  (* res i)) res)))

** Хвостовая рекурсия
   :PROPERTIES:
   :CUSTOM_ID: хвостовая-рекурсия
   :END:
Хвостовой вызов - вызов, который является последним, результат этого
вызова становится результатом работы функции.

#+begin_example
  (define (f x y z)
    (if (a)
        (b x (c y))
        (d (if (e)
               (g)
               (h)))))
#+end_example

(Вызовы b и d - хвостовые)

В языке Scheme заложена оптимизация хвостового вызова, т.н. оптимизация
хвостовой рекурсии. Фрейм стека (см. лекцию про продолжения) вызывающей
процедуры замещается фреймом стека вызываемой процедуры.

Если хвостовой вызов является рекурсивным, фреймы стека не
накапливаются.

*Хвостовая рекурсия в языке Scheme эквивалента итерации* по
вычислительным затратам.

Рекурсивный факториал:

#+begin_example
  (define (fact N)
    (if (> N 0)
        (* (fact (- N 1)) N)
        1))
#+end_example

Итеративный факториал:

#+begin_example
  (define (fact N)
    (define (loop i res)
      (if (<= i N)
          (loop (+ i 1)
                (* res i))
          res))
    (loop 1 1))
#+end_example

Оптимизация хвостовой рекурсии изнутри:

#+begin_example
  int loop(int N, int i, int res) {
    if (i <= N) {
      loop(N, i + 1, res * i);
    } else {
      return res;
    }
  }

  int loop(int N, int i, int res) {
  LOOP:
    if (i <= N) {
      res = res * i;
      i = i + 1;
      goto LOOP;
    } else {
      return res;
    }
  }
#+end_example
