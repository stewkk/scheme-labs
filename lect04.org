* Лекция 4. Списки
  :PROPERTIES:
  :CUSTOM_ID: лекция-4.-списки
  :END:
LISP --- List processing, обработка списков. Список --- основная
структура данных языка Scheme.

(1 2 3 4) --- список из четырёх чисел.

Создание списка

#+begin_example
  (list <элементы>)

  (list 1 2 3 4)    →    (1 2 3 4)
  (list)            →    ()
#+end_example

Операции над списками:

*** =cons= --- конструирование
    :PROPERTIES:
    :CUSTOM_ID: cons-конструирование
    :END:
#+begin_example
  (cons <голова> <хвост>) → <список>
#+end_example

Создаёт новый список из некоторого значения («головы») и другого списка
(«хвоста»). Первым элементом нового списка будет «голова»,
последующими --- хвост.

#+begin_example
  (cons 1 (list 2 3 4))   →   (1 2 3 4)
#+end_example

*** =car=, =cdr=, =null?=
    :PROPERTIES:
    :CUSTOM_ID: car-cdr-null
    :END:
#+begin_example
  (car <список>) → <голова списка>
  (cdr <список>) → <хвост списка>
  (null? <список>) → <bool>
#+end_example

Это селекторы, запрашивают голову и хвост списка, список должен быть
непустым.

#+begin_example
  (car (list 1 2 3 4)) → 1
  (cdr (list 1 2 3 4)) → (2 3 4)

  (null? (list 1 2 3 4)) → #f
  (null? (list)) → #t
#+end_example

Пустой список, запись списка через цитирование

#+begin_example
  '() — пустой список
#+end_example

Запись списка при помощи цитирования:

#+begin_example
  '(1 (2 3 4) 5 6)
#+end_example

Вложенные списки:

#+begin_example
  (list (list 1 2 3) (list 4 5 6)) → ((1 2 3) (4 5 6))
  '((1 2 3) (4 5 6))               → ((1 2 3) (4 5 6))
#+end_example

Список можно связать с переменной:

#+begin_example
  (define L '(1 2 3))

  (define x 1)

  (define (f y)
    (list x y))

  (define (f y)
    (cons x (cons y '())))

  '(x y)
#+end_example

Встроенная функция =length=

#+begin_example
  (length '(1 1 2 1)) → 4
#+end_example

Встроенная функция =append= --- конкатенация списков:

#+begin_example
  (append '(1 2 3) '(4 5 6)) → (1 2 3 4 5 6)

  (append '(1 2) '(3 4) '(5 6)) → (1 2 3 4 5 6)
#+end_example

* Списков не существует --- cons-ячейки или пары
  :PROPERTIES:
  :CUSTOM_ID: списков-не-существует-cons-ячейки-или-пары
  :END:
Объект, который строится функцией =cons= --- т.н. cons-ячейка или пара.
Аргументами функции =cons= могут быть любые объекты.

Правильный список --- это или пустой список, или cons-пара, вторым
элементом которой является правильный список.

#+begin_example
  (cons 1 2)            → (1 . 2)   ;; неправильный список
  (cons 1 (cons 2 '())) → (1 2)     ;; правильный список


  (cons 1 (cons 2 (cons 3 4))) → (1 2 3 . 4)  ;; тоже неправильный список
#+end_example

Пример. Как могла бы быть определена встроенная функция =length=:

#+begin_example
  (define (length xs)
    (if (null? xs)
        0
        (+ 1 (length (cdr xs)))))

  (define (length xs)
    (define (loop len xs)
      (if (null? xs)
          len
          (loop (+ len 1) (cdr xs))))
    (loop 0 xs))
#+end_example

Функция =pair?= возвращает истину, если аргумент --- cons-ячейка.

** Встроенная функция =map=
   :PROPERTIES:
   :CUSTOM_ID: встроенная-функция-map
   :END:
Используется для того, чтобы единообразно преобразовать все элементы
списка, принимает процедуру и исходный список, строит новый список
той же длины, что и исходный, каждый элемент этого списка является
результатом применения процедуры к элементу исходного списка.

#+begin_example
  (define (square x) (* x x))
  (map square '(1 2 3 4 5))  →  '(1 4 9 16 25)
#+end_example

Расширенный вариант использования =map=:

#+begin_example
  (map
    (lambda (x y) (+ (* 2 x) (* 3 y)))
    '(1 2 1 2)
    '(2 3 2 3 2)
  ) →
    '(8 13 8 13)
#+end_example

Функцию =map= («простой вариант») можно описать как:

#+begin_example
  (define (map f xs)
    (if (null? xs)
        '()
        (cons (f (car xs)) (map f (cdr xs)))))
#+end_example

* Процедуры с переменным числом параметров
  :PROPERTIES:
  :CUSTOM_ID: процедуры-с-переменным-числом-параметров
  :END:
Безымянная процедура, принимающая произвольное число аргументов:

#+begin_example
  (lambda xs …)
#+end_example

=xs= --- список аргументов

#+begin_example
  ((lambda xs xs) 1 2 3 4) → (1 2 3 4)
#+end_example

Безымянная процедура, принимающая n+ аргументов:

#+begin_example
  (lambda (a b c . xs) …)

  ((lambda (a b c . xs)
     (list (+ a b c) xs))
   1 2 3 4 5) →
     (6 (4 5))
#+end_example

Именованная процедура:

#+begin_example
  (define (f <фиксированные параметры> . <список параметров>)
    …)

  (define (f a b c . xs)
    (list (+ a b c) xs))

  (f 1 2 3 4 5) → (6 (4 5))

  (define (f . xs)
    (list xs xs))

  (f 1 2 3) → ((1 2 3) (1 2 3))
#+end_example

Функцию =list= можно описать так:

#+begin_example
  (define (list . xs) xs)
#+end_example

Пример:

#+begin_example
  ((lambda x x)) → ()
#+end_example

* Вычислительная сложность
  :PROPERTIES:
  :CUSTOM_ID: вычислительная-сложность
  :END:
Вычислительная сложность --- асимптотическая оценка времени работы
программы. Асимптотическая, значит, нас интересует не конкретное время,
а поведение.

=T(<данные>)= --- функция, возвращающая точное значение времени работы
программы на конкретных входных данных.

Асимптотическая оценка =O(f(<данные>))= показывает, что функция =T(•)=
при росте входных данных ведёт себя как функция =f(•)= с точностью
до некоторого постоянного сомножителя.

Т.е. существует такое =k=, что

#+begin_example
  T(data) <= k×f(data)
#+end_example

при росте аргумента =data=.

Оценку вычислительной сложности для некоторого алгоритма и некоторого
абстрактного вычислителя обычно оценивают в числе элементарных команд
этого абстрактного вычислителя.

Для Scheme элементарными операциями считаются вызов функции, =cons=,
=car=, =cdr=, получение значения переменной, создание процедуры
(=lambda=), объявление глобальной переменной (=define=), присваивание
переменной (=set!=), арифметические действия с фиксированным числом
операндов (не свёртка!), call/cc (создание и переход на продолжение),
=delay=, =force=, =null?= (и другие встроенные предикаты), =if=, =cond=.

Встроенные функции могут иметь разную сложность!

Например,

- =(map f xs)= --- =O(len(xs)×T(f))=, где =T(f)= --- среднее время
  работы =(f x)=.
- =(length xs)= --- =O(len(xs))=.
- =(append xs ys)= --- =O(len(xs))=.

.

#+begin_example
  (define (append xs ys)
    (if (null? xs)
        ys
        (cons (car xs) (append (cdr xs) ys))))
#+end_example

* Замыкания, области видимости и захват переменных
  :PROPERTIES:
  :CUSTOM_ID: замыкания-области-видимости-и-захват-переменных
  :END:
#+begin_example
  (define (f x)
    (lambda (y) (+ x y))

  (define f1 (f 1))
  (define f7 (f 7))

  (f1 10) → 11
  (f7 10) → 17
#+end_example

* Проверка на равенство
  :PROPERTIES:
  :CUSTOM_ID: проверка-на-равенство
  :END:

- =eqv?= --- атомы сравнивает по значению, сложные типы данных (списки,
  векторы, lambda) --- по ссылке.
- =eq?= --- может и атомы сравнивать по ссылке.
- =equal?= --- сравнивает аргументы по значению.
- === --- равенство чисел. Может сравнивать числа разных типов.
- Функции сравнения отдельных типов вроде =string=?=...

Функция =equal?= медленная, т.к. сравнивает аргументы по значению,
в частности, для списков сравнивает их содержимое. Но она наиболее
предсказуемая.

Функции =eq?= и =eqv?= работают быстро, но могут давать неожиданные
результаты.

#+begin_example
  (define x …)
  (define y x)

  (eq? x y)     → #t
  (eqv? x y)    → #t
  (equal? x y)  → #t
#+end_example
