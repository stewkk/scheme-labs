
;; appendix/parser/stream.scm:
;; Конструктор потока
(define (make-stream items . eos)
  (if (null? eos)
      (make-stream items #f)
      (list items (car eos))))

;; Запрос текущего символа
(define (peek stream)
  (if (null? (car stream))
      (cadr stream)
      (caar stream)))

;; Запрос первых двух символов
(define (peek2 stream)
  (if (null? (car stream))
      (cadr stream)
      (if (null? (cdar stream))
          (list (caar stream))
          (list (caar stream) (cadar stream)))))

;; Продвижение вперёд
(define (next stream)
  (let ((n (peek stream)))
    (if (not (null? (car stream)))
        (set-car! stream (cdr (car stream))))
    n))
;; end of appendix/parser/stream.scm

(define (tokenize str)
  ;; (load "appendix/parser/stream.scm")
  (define (expression stream error)
    (cond ((and (char? (peek stream))
                (or (char-whitespace? (peek stream))
                    (member (peek stream)
                            '(#\( #\) #\+ #\- #\* #\/ #\^))
                    (char-alphabetic? (peek stream))
                    (char-numeric? (peek stream))))
           (spaces stream error)
           (let* ((t-object (object stream error))
                  (t-spaces (spaces stream error))
                  (t-expr (expression stream error)))
             (cons t-object t-expr)))
          (else '())))
  (define (spaces stream error)
    (cond ((and (char? (peek stream))
                (char-whitespace? (peek stream)))
           (next stream)
           (spaces stream error))
          (else '())))
  (define (object stream error)
    (cond ((assoc (peek stream) '((#\( "(")
                                  (#\) ")")
                                  (#\+ +)
                                  (#\- -)
                                  (#\* *)
                                  (#\/ /)
                                  (#\^ ^))) => (lambda (ret)
                                                  (next stream)
                                                  (cadr ret)))
          ((and (char? (peek stream))
                (char-alphabetic? (peek stream)))
           (variable stream error))
          ((and (char? (peek stream))
                (char-numeric? (peek stream)))
           (number stream error))
          (else (error '())))) ;; TODO плохой фикс
  (define (number stream error)
    (cond ((and (char? (peek stream))
                (char-numeric? (peek stream)))
           (let* ((n (next stream))
                  (n-tail (number-tail stream error)))
             (string->number (list->string (cons n n-tail)))))
          (else (error #f))))
  (define (number-tail stream error)
    (cond ((and (char? (peek stream))
                (or (char-numeric? (peek stream))
                    (char=? #\e (peek stream))
                    (char=? #\. (peek stream))))
           (let* ((n (next stream))
                  (n-tail (number-tail stream error)))
             (cons n n-tail)))
          (else '())))
  (define (variable stream error)
    (cond ((and (char? (peek stream))
                (char-alphabetic? (peek stream)))
           (let* ((letter (next stream))
                  (var-tail (variable-tail stream error)))
             (string->symbol (list->string (cons letter var-tail)))))
          (else (error #f))))
  (define (variable-tail stream error)
    (cond ((and (char? (peek stream))
                (char-alphabetic? (peek stream)))
           (let* ((letter (next stream))
                  (var-tail (variable-tail stream error)))
             (cons letter var-tail)))
          (else '())))
  (define stream (make-stream (string->list str) 'EOF))
  (call-with-current-continuation
   (lambda (error)
     (define res (expression stream error))
     (and (eqv? (peek stream) 'EOF)
          res))))

(define (parse tokens)
  ;; (load "appendix/parser/stream.scm")
  (define (expr stream error)
    (let loop ((res (term stream error)))
      (cond ((or (eqv? '+ (peek stream))
                 (eqv? '- (peek stream)))
             (let* ((op (next stream))
                    (t-term (term stream error)))
               (loop (list res op t-term))))
            (else res))))
  (define (term stream error)
    (let loop ((res (factor stream error)))
      (cond ((or (eqv? '* (peek stream))
                 (eqv? '/ (peek stream)))
             (let* ((op (next stream))
                    (t-factor (factor stream error)))
               (loop (list res op t-factor))))
            (else res))))
  (define (factor stream error)
    (let* ((t-power (power stream error))
           (t-factor1 (factor1 stream error)))
      (if (null? t-factor1)
          t-power
          (cons t-power t-factor1))))
  (define (factor1 stream error)
    (cond ((eqv? '^ (peek stream))
           (next stream)
           (let* ((t-power (power stream error))
                  (t-factor1 (factor1 stream error)))
             (if (null? t-factor1)
                 (cons '^ (list t-power))
                 (list '^ (cons t-power t-factor1)))))
          (else '())))
  (define (power stream error)
    (cond ((number? (peek stream))
           (next stream))
          ((equal? "(" (peek stream))
           (next stream)
           (let ((t-expr (expr stream error)))
             (if (not (equal? ")" (peek stream)))
                 (error #f))
             (next stream)
             t-expr))
          ((eqv? '- (peek stream))
           (next stream)
           (list '- (power stream error)))
          ((symbol? (peek stream))
           (next stream))
          (else (error #f))))
  (define stream (make-stream tokens "EOF"))
  (call-with-current-continuation
   (lambda (error)
     (define res (expr stream error))
     (and (equal? (peek stream) "EOF")
          res))))

(define (tree->scheme tree)
  (cond ((not (list? tree))
         tree)
        ((eqv? '- (car tree))
         (list '- (tree->scheme (cadr tree))))
        ((eqv? '^ (cadr tree))
         (list 'expt
               (tree->scheme (car tree))
               (tree->scheme (caddr tree))))
        (else (list (cadr tree)
                    (tree->scheme (car tree))
                    (tree->scheme (caddr tree))))))
