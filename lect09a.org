* Лекция 9а. Ввод-вывод в языке Scheme
  :PROPERTIES:
  :CUSTOM_ID: лекция-9а.-ввод-вывод-в-языке-scheme
  :END:
Мы будем рассматривать сегодня ввод-вывод в языке Scheme R5RS. Язык
Scheme R5RS --- не промышленный, а академический, поэтому средства
ввода-вывода в нём довольно ограничены.

Для сравнения, Common Lisp --- промышленный язык, в нём средства
ввода-вывода более обширны.

Для абстракции ввода-вывода в Scheme R5RS используется понятие порта.
Есть порт ввода и порт вывода по умолчанию, можно создавать новые порты,
связанные с файлами.

** Порты ввода-вывода, открытие и закрытие
   :PROPERTIES:
   :CUSTOM_ID: порты-ввода-вывода-открытие-и-закрытие
   :END:
Порт ввода по умолчанию связан с клавиатурой (=stdin=, в терминах языка
Си), порт вывода --- с экраном (=stdout=, в терминах языка Си). Эти
порты по умолчанию можно переназначать.

Предикат типа «порт»:

#+begin_example
  (port? x)                          → #t или #f
#+end_example

Создание порта:

#+begin_example
  (open-input-port "имя файла")      → port
  (open-output-port "имя файла")     → port
#+end_example

Предусловие для =open-output-port=: файл существовать не должен (иначе
ошибка).

После использования порты, связанные с файлами, нужно закрывать:

#+begin_example
  (close-input-port port)
  (close-output-port port)
#+end_example

Порты по умолчанию:

#+begin_example
  (current-input-port)               → port
  (current-output-port)              → port
#+end_example

Временное перенаправление портов:

#+begin_example
  (with-output-to-file "имя файла" proc)       ≡ (proc)
  (with-input-from-file "имя файла" proc)      ≡ (proc)
#+end_example

Здесь =proc= --- процедура без параметров, во время выполнения этой
процедуры порты вывода и ввода, соответственно, по умолчанию будут
перенаправлены.

Возвращаемое значение у этих функций то же, что у вызванной процедуры.

#+begin_example
  (with-output-to-file "D:/test.txt"
    (lambda ()
      (display 'hello)))
#+end_example

В файл =D:/test.txt= будет записана строчка =hello=.

Открытие портов с автоматическим закрытием:

#+begin_example
  (call-with-input-file "имя файла" proc)      ≡ (proc port)
  (call-with-output-file "имя файла" proc)     ≡ (proc port)
#+end_example

Здесь функция =proc= будет принимать порт в качестве параметра:

#+begin_example
  (call-with-output-file "D:/test2.txt"
    (lambda (port)
      (display 'hello port)))
#+end_example

Порт, переданный в процедуру, будет закрыт при завершении вызова самой
процедуры.

** Чтение и запись символов
   :PROPERTIES:
   :CUSTOM_ID: чтение-и-запись-символов
   :END:
Для чтения и записи используются функции =read-char=, =peek-char=,
=write-char=:

#+begin_example
  (read-char)                        → char | eof-object
  (read-char port)                   → char | eof-object

  (peek-char)                        → char | eof-object
  (peek-char port)                   → char | eof-object

  (write-char char)
  (write-char char port)
#+end_example

Если порт не указан, то используется порт по умолчанию. Функции
=read-char= и =peek-char= возвращают либо литеру, либо признак конца
файла (end-of-file). Проверка прочитанного на конец файла делается
предикатом:

#+begin_example
  (eof-object? obj)                  → #t | #f
#+end_example

Функция =read-char= читает литеру и забирает его из источника, функция
=peek-char= --- читает литеру и оставляет её в источнике. Т.е. вызов

#+begin_example
  (let* ((x (read-char))
         (y (read-char))
         (z (read-char)))
     (list x y z))
#+end_example

вернёт три последовательных символа из порта. Вызов

#+begin_example
  (let* ((x (peek-char))
         (y (peek-char))
         (z (peek-char)))
     (list x y z))
#+end_example

построит список из трёх одинаковых литер, причём литера останется
во входом порту --- её можно будет получить следующим вызовом
=read-char= или =peek-char=.

** Ввод-вывод выражений
   :PROPERTIES:
   :CUSTOM_ID: ввод-вывод-выражений
   :END:
Можно читать и записывать целые s-выражения, синтаксический анализ будет
выполнен библиотекой, а мы получим готовое выражение.

#+begin_example
  (write expr)
  (write expr port)
#+end_example

Функция =write= выписывает в порт выражение в машиночитаемом виде. Т.е.
выписанное выражение однозначно понятно. Для чтения машиной записанного
выражения используется функция

#+begin_example
  (read)                             → expr | eof-object
  (read port)                        → expr | eof-object
#+end_example

То, что мы записали при помощи =write=, мы можем потом прочитать при
помощи =read=. Однако, не все данные поддаются чтению обратно.

Снова прочитать мы можем только данные следующих типов:

- =#t=, =#f=,
- числа: =100500=, =2/3=, =3.1415926=, =7+2i=,
- строки: ="Hello!"=,
- литеры: =#\H=, =#\!=, =#\newline=,
- символы: ='hello=,
- списки и вектора всего вышеперечисленного.

Снова прочитать мы можем только объекты, для которых существуют
литералы. Собственно, функция =write= и выписывает данные в виде
литералов, а функция =read= их разбирает.

Снова прочитать мы не можем объекты, существующие при выполнении
конкретного процесса: процедуры (=lambda=), порты, продолжения
(continuations). Для двух последних литералов не существует. Синтаксис
=(lambda …)= можно считать литералом для процедуры, но процедура ---
вещь существенно динамическая, т.к. захватывает переменные из своего
окружения (см. идиому статических переменных).

** Прочий вывод
   :PROPERTIES:
   :CUSTOM_ID: прочий-вывод
   :END:
Здесь рассмотрим вывод человекочитаемых данных, он представлен двумя
функциями:

#+begin_example
  (display)
  (display port)
  (newline)
  (newline port)
#+end_example

=display= выводит данные в человекочитаемом виде. Т.е. строки выводятся
не как свои литералы, а с буквальной интерпретацией символов в них
(перевод строки приведёт к печати перевода строки в файле, а не выдаче
литер =\= и =n=). Вывод следующих трёх вызовов будет идентичен:

#+begin_example
  (display #\x)
  (display "x")
  (display 'x)
#+end_example

По выводу будет непонятно, что же было реальным аргументом. Но, когда
пользуются функцией =display=, это и не нужно.

Если для отладки нужно выводить какое-то выражение, то его лучше
выводить при помощи =write=, т.к. по выводу будет однозначно понятно
содержимое. В частности, =write= следует использовать в макросе
=trace-ex= и каркасе модульных тестов в ЛР3 для вывода выражений.

** REPL (read-evaluate-print loop)
   :PROPERTIES:
   :CUSTOM_ID: repl-read-evaluate-print-loop
   :END:
REPL (read-evaluate-print loop) --- режим интерактивной работы
с интерпретируемыми языками программирования. Пользователь вводит
конструкцию языка (выражение, оператор), она тут же интерпретируется
и результат выводится на экран. После чего пользователь может снова
что-то ввести.

Впервые REPL появился для языка LISP, сейчас он поддерживается многими
интерпретаторами языков программирования. Например, среда IDLE в Python,
консоль JavaScript, доступная в любом браузере (часто вызывается
по F12).

REPL можно реализовать в Scheme самостоятельно:

#+begin_example
  (define (print expr)
    (write expr)
    (newline))

  (define (REPL)
    (let* ((e (read))                                    ; read
           (r (eval e (interaction-environment)))        ; eval
           (_ (print r)))                                ; print
       (REPL)))                                          ; loop
#+end_example

Добавим поддержку конца файла:

#+begin_example
  (define (REPL)
    (let* ((e (read)))                                   ; read
      (if (not (eof-object? e))
          (let* ((r (eval e (interaction-environment)))  ; eval
                 (_ (print r)))                          ; print
            (REPL)))))                                   ; loop
#+end_example

Встроенная функция =load= позволяет прочитать и проинтерпретировать
содержимое файла:

#+begin_example
  (load "trace.scm")
  (load "unit-tests.scm")
#+end_example

Аналог функции =load= можно написать самостоятельно:

#+begin_example
  (define (my-load filename)
    (with-input-from-file filename REPL))
#+end_example

*Примечание.* Чтобы среда DrRacket не печатала =#<void>= для конструкций
без значения в нашем импровизированном REPL'е, функцию =print= можем
уточнить:

#+begin_example
  (define the-void (if #f #f))

  (define (print expr)
    (if (not (equal? expr the-void))
        (begin
          (write expr)
          (newline))))
#+end_example
