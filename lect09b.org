* Лекция 9б. Мемоизация и нестрогие вычисления
  :PROPERTIES:
  :CUSTOM_ID: лекция-9б.-мемоизация-и-нестрогие-вычисления
  :END:
*Мемоизация* --- оптимизация, позволяющая избегать повторного вычисления
функции, вызванной с теми же аргументами, как и в один из прошлых
вызовов.

В общем случае нужно мемоизировать чистые функции: детерминированные
и без побочных эффектов. Обоснование:

- Нет смысла мемоизировать функцию =(read port)= --- она на каждом
  вызове должна выдавать очередное значение из файла.
- Нет смысла мемоизировать функцию =(display message)=, т.к. она должна
  выполнять побочный эффект.

Пример мемоизации «нечистой» функции. Функция =(get-messages lang-id)=
загружает из файла ресурсов сообщения программы на некотором языке.
В процессе работы программы пользователь может залезть в настройки
и поменять выбранный язык. Если функцию вызывать при каждой потребности
вывести на экран сообщение, то она будет многократно читать один
и тот же файл. Если загружать все ресурсы для всех языков в начале
работы программы, то будут загружены лишние ресурсы. Приемлемый
вариант --- мемоизировать вызовы =get-messages=.

*Приём мемоизации в Scheme.* Пусть нам нужно мемоизировать функцию вида

#+begin_example
  (define (func x y z)
    (+ x y z))
#+end_example

Данная функция должна при вызове с ранее известными аргументами
«вспоминать» свой результат, не вычисляя его заново. Но если аргументы
новые, она должна результат вычислить и запомнить его.

Для этой цели нам нужно некоторое хранилище, где мы будем сопоставлять
аргументы с вычисленными результатами. Для этой цели проще всего
использовать ассоциативный список. Делать хранилище открытым тоже
не стоит --- снаружи должна быть видна только функция =func= (хороший
стиль --- минимизировать область видимости переменных). Соответственно,
будем использовать приём статических переменных в языке Scheme:

#+begin_example
  (define func-memo
    (let ((known-results '()))
      (lambda (x y z)
         ...)))
#+end_example

Если значения аргументов есть в хранилище, то нужно вернуть известный
результат. Если нет --- вычислить и положить в список =known-results=:

#+begin_example
  (define func-memo
    (let ((known-results '()))
      (lambda (x y z)
        (let* ((args (list x y z))
               (res (assoc args known-results)))
          (if res
              (cadr res)
              (let (res (+ x y z))
                (set! known-results (cons (list args res) known-results))
                res))))))
#+end_example

Так мы запоминаем все предыдущие значения. Иногда функция часто
вызывается с теми же значениями, которые были в прошлый раз. Тогда имеет
смысл запоминать только последнее значение:

#+begin_example
   (define func-memo-last
     (let ((last-arg #f)
           (known-result #f))
        (lambda (x y z)
          (let ((arg (list x y z)))
            (if (equal? arg last-arg)
              known-result
              (let ((res (+ x y z)))
                (set! last-arg arg)
                (set! known-result res)
                res))))))
#+end_example

*Строгие вычисления* --- аргументы функции полностью вычисляются
до того, как эта функция вызывается. Вызовы процедур в Scheme всегда
строгие. Строгую стратегию вычислений часто называют call-by-value.

В случае *нестрогих вычислений* значения выражений могут вычисляться
по необходимости, их вызов может быть отложен.

Примеры нестрогих вычислений:

- =(if cond then else)= --- вычисляется либо =then=, либо =else=.
- =(and …)=, =(or …)=.
- В языке Си логические операции =&&=, =||= тоже не строгие.

В теории рассматривают две разновидности нестрогих вычислений:

- call-by-name, вызов по имени --- нормальная редукция
  в лябмда-исчислении,
- call-by-need, вызов по необходимости --- ленивые вычисления.

В некотором смысле разновидность call-by-name --- макроподстановка:

#+begin_src scheme
  (define-syntax double
    (syntax-rules ()
      ((double x) (+ x x)))

  (define-syntax ++
    (syntax-rules ()
      ((++ var) (begin (set! var (+ var 1))
                       var))))

  (define x 10)

  (double (++ x))  ;; выведет 23
  x                ;; выведет 12
#+end_src

Вызов по имени в Алголе-60

#+begin_example
  function sum(i, start, end, val): real;
      integer i, start, end;
      real val;
      value start, end;
  begin
    real res := 0;
    for i := start to end do
      res := res + val;

    comment почему нельзя res := (end - start + 1) * val?;

    sum := res
  end;

  function square(x): real;
       integer x;
  begin
    square := x * x;
  end;

  real temperature[1 : 100];

  integer k;

  print(sum(k, 1, 10, square(k)));
  print(sum(k, 1, 100, temperature[k]) / 100);
#+end_example

Пример стратегии =call-by-need= --- ленивый язык программирования
Хаскель

#+begin_src haskell
  test xs = head (map (\x -> x*x) xs)
#+end_src

Будет вычисляться квадрат только самого первого элемента списка.

** Примитивы Scheme для обеспечения ленивых вычислений
   :PROPERTIES:
   :CUSTOM_ID: примитивы-scheme-для-обеспечения-ленивых-вычислений
   :END:
Это макрос =(delay expr)= и функция =(force promise)=. Макрос =delay=
принимает выражение и формирует обещание (promise) вычислить это
выражение, когда потребуется. =force= вычисляет этот promise, результат
мемоизируется.

В первом приближении:

#+begin_src scheme
  (define-syntax delay
    (syntax-rules ()
      ((delay expr) (lambda () expr))))

  (define (force promise)
    (promise))
#+end_src

С мемоизацией:

#+begin_src scheme
  (define-syntax delay
    (syntax-rules ()
      ((delay expr) (list #f (lambda () expr)))))

  (define (force promise)
    (if (car promise)
        (caar promise)
        (begin
          (set-car! (list ((cadr promise))))
          (caar promise))))
#+end_src
