(define (tokenize str)
  (load "appendix/parser/stream.scm")
  (define (expression stream error)
    (cond ((and (char? (peek stream))
                (or (char-whitespace? (peek stream))
                    (member (peek stream)
                            '(#\( #\) #\+ #\- #\* #\/ #\^))
                    (char-alphabetic? (peek stream))
                    (char-numeric? (peek stream))))
           (spaces stream error)
           (let* ((t-object (object stream error))
                  (t-spaces (spaces stream error))
                  (t-expr (expression stream error)))
             (cons t-object t-expr)))
          (else '())))
  (define (spaces stream error)
    (cond ((and (char? (peek stream))
                (char-whitespace? (peek stream)))
           (next stream)
           (spaces stream error))
          (else '())))
  (define (object stream error)
    (cond ((assoc (peek stream) '((#\( "(")
                                  (#\) ")")
                                  (#\+ +)
                                  (#\- -)
                                  (#\* *)
                                  (#\/ /)
                                  (#\^ ^))) => (lambda (ret)
                                                  (next stream)
                                                  (cadr ret)))
          ((and (char? (peek stream))
                (char-alphabetic? (peek stream)))
           (variable stream error))
          ((and (char? (peek stream))
                (char-numeric? (peek stream)))
           (number stream error))
          (else (error #f))))
  (define (number stream error)
    (cond ((and (char? (peek stream))
                (char-numeric? (peek stream)))
           (let* ((n (next stream))
                  (n-tail (number-tail stream error)))
             (string->number (list->string (cons n n-tail)))))
          (else (error #f))))
  (define (number-tail stream error)
    (cond ((and (char? (peek stream))
                (or (char-numeric? (peek stream))
                    (char=? #\e (peek stream))
                    (char=? #\. (peek stream))))
           (let* ((n (next stream))
                  (n-tail (number-tail stream error)))
             (cons n n-tail)))
          (else '())))
  (define (variable stream error)
    (cond ((and (char? (peek stream))
                (char-alphabetic? (peek stream)))
           (let* ((letter (next stream))
                  (var-tail (variable-tail stream error)))
             (string->symbol (list->string (cons letter var-tail)))))
          (else (error #f))))
  (define (variable-tail stream error)
    (cond ((and (char? (peek stream))
                (char-alphabetic? (peek stream)))
           (let* ((letter (next stream))
                  (var-tail (variable-tail stream error)))
             (cons letter var-tail)))
          (else '())))
  (define stream (make-stream (string->list str) 'EOF))
  (call-with-current-continuation
   (lambda (error)
     (define res (expression stream error))
     (and (eqv? (peek stream) 'EOF)
          res))))

(load "unit-test.scm")

(define tokenize-tests
  (list (test (tokenize "1")
              (1))
        (test (tokenize "-a")
              (- a))
        (test (tokenize "-a + b * x^2 + dy")
              (- a + b * x ^ 2 + dy))
        (test (tokenize "(a - 1)/(b + 1)")
              ("(" a - 1 ")" / "(" b + 1 ")"))))

(run-tests tokenize-tests)

(define (parse tokens)
  (load "appendix/parser/stream.scm")
  (define (expr stream error)
    (let loop ((res (term stream error)))
      (cond ((or (eqv? '+ (peek stream))
                 (eqv? '- (peek stream)))
             (let* ((op (next stream))
                    (t-term (term stream error)))
               (loop (list res op t-term))))
            (else res))))
  (define (term stream error)
    (let loop ((res (factor stream error)))
      (cond ((or (eqv? '* (peek stream))
                 (eqv? '/ (peek stream)))
             (let* ((op (next stream))
                    (t-factor (factor stream error)))
               (loop (list res op t-factor))))
            (else res))))
  (define (factor stream error)
    (let* ((t-power (power stream error))
           (t-factor1 (factor1 stream error)))
      (if (null? t-factor1)
          t-power
          (cons t-power t-factor1))))
  (define (factor1 stream error)
    (cond ((eqv? '^ (peek stream))
           (next stream)
           (let* ((t-power (power stream error))
                  (t-factor1 (factor1 stream error)))
             (if (null? t-factor1)
                 (cons '^ (list t-power))
                 (list '^ (cons t-power t-factor1)))))
          (else '())))
  (define (power stream error)
    (cond ((number? (peek stream))
           (next stream))
          ((equal? "(" (peek stream))
           (next stream)
           (let ((t-expr (expr stream error)))
             (next stream)
             t-expr))
          ((eqv? '- (peek stream))
           (next stream)
           (list '- (power stream error)))
          ((symbol? (peek stream))
           (next stream))
          (else (error #f))))
  (define stream (make-stream tokens "EOF"))
  (call-with-current-continuation
   (lambda (error)
     (define res (expr stream error))
     (and (equal? (peek stream) "EOF")
          res))))

(load "unit-test.scm")

(define parse-tests
  (list (test (parse (tokenize "a + b + c+d"))
              (((a + b) + c) + d))
        (test (parse (tokenize "a/b/c/d"))
              (((a / b) / c) / d))
        (test (parse (tokenize "a^b^c^d"))
              (a ^ (b ^ (c ^ d))))
        (test (parse (tokenize "a/(b/c)"))
              (a / (b / c)))
        (test (parse (tokenize "a + b/c^2 - d"))
              ((a + (b / (c ^ 2))) - d))
        (test (parse (tokenize "(-a)^1e10"))
              ((- a) ^ 1e10))))

(run-tests parse-tests)

(define (tree->scheme tree)
  (cond ((not (list? tree))
         tree)
        ((eqv? '- (car tree))
         (list '- (tree->scheme (cadr tree))))
        ((eqv? '^ (cadr tree))
         (list 'expt
               (tree->scheme (car tree))
               (tree->scheme (caddr tree))))
        (else (list (cadr tree)
                    (tree->scheme (car tree))
                    (tree->scheme (caddr tree))))))

(load "unit-test.scm")

(define tree->scheme-tests
  (list (test (tree->scheme (parse (tokenize "x^(a + 1)")))
              (expt x (+ a 1)))
        (test (eval (tree->scheme (parse (tokenize "2^2^2^2")))
                    (interaction-environment))
              65536)))

(run-tests tree->scheme-tests)
